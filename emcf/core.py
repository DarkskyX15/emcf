
from ._database import *
from ._exceptions import MCFComponentError
from ._utils import getMultiPaths, console
from typing import (
    TypeAlias, Any, Literal, TextIO, Callable, Protocol, TypeVarTuple,
    TypedDict, Required
)
import os, random, atexit

EMCF = "a0.2.2"

GCSign: TypeAlias = Literal['shadow', 'norm', 'none']

class ConfigMap(TypedDict, total=False):
    namespace: Required[str]
    version: Required[Literal[57]]
    dist: str
    prefix: str
    gc: bool
    log: bool
    
ContextType: TypeAlias = Literal[
    'norm', 'loop', 'if', 'elif', 'else'
]

MCFVersion: TypeAlias = Literal[1204, 1211]

class FoolID:
    _present: list[int]
    _chars: list[str]
    def __init__(self):
        self._present = []
        self._chars = []

        self._present = [0]
        for i in range(ord('a'), ord('z')):
            self._chars.append(chr(i))
        random.shuffle(self._chars)
    
    def get(self) -> str:
        fid = ''.join([self._chars[idx] for idx in self._present])
        last = len(self._present)
        self._present[last - 1] += 1
        for i in range(last - 1, -1, -1):
            if self._present[i] >= len(self._chars):
                if i == 0:
                    self._present[i] = 0
                    self._present.insert(0, 0)
                    break
                else:
                    self._present[i] = 0
                    self._present[i - 1] += 1
        return fid

class MCFCore:
    _namespace: str
    _mcf_version: MCFVersion
    _dist: str
    wk_root: str

    _operation_stack: list
    _fool_id_generator: FoolID
    _prefix: str
    _io_ptr: str
    _io_history: list[str]
    _io_redirect: Any | None
    _component_reg: dict[str, str]
    _final_export: bool
    _tidied_up: bool
    _context: dict[str, Any]
    _context_stack: list[dict[str, Any]]
    _context_type: list[ContextType]
    _last_ctx_type: ContextType
    _init_helper: list[Callable]
    _func_queue: list[Any]

    sb_general: str
    sb_sys: str
    storage: str
    database: MCFDataBase
    do_gc: bool
    stop_gc: bool

    GENERAL = "reg1"
    BUFFER1 = "reg5"
    BUFFER2 = "reg6"
    BUFFER3 = "reg7"
    BUFFER4 = "reg8"
    BUFFER5 = "reg9"
    BUFFER6 = "re10"
    CALC_CONST = "reg2"
    COND_LAST = "reg3"
    TERMINATE = "reg4"
    LOOP_EXIT = "re11"
    LOOP_CONT = "re12"

    def __init__(self):
        self._operation_stack = []
        self._mcf_version = 57
        self._dist = "./build"
        self.wk_root = "./build/default/functions"
        self._namespace = "default"
        self._prefix = """--- Generated by EMCF ---"""
        self._fool_id_generator = FoolID()
        self._io_history = []
        self._io_ptr = None
        self._component_reg = dict()
        self._final_export = False
        self._tidied_up = False
        self._context = {}
        self._context_stack = []
        self._context_type = ['norm']
        self._last_ctx_type = 'norm'
        self._init_helper = []
        self._io_redirect = None
        self.do_gc = True
        self.stop_gc = False
        self._func_queue = []
        atexit.register(self._deconstruct)
        console.info(f'EMCF initialized, version: {EMCF}')

    def __del__(self):
        pass

    def _deconstruct(self):
        if not self._tidied_up:
            self.tidyUp()

    def tidyUp(self) -> None:
        self._tidied_up = True

        # write reset
        path, _ = MCF.makeFunction("reset")
        MCF.forward(path)
        MCF.write(
f"""scoreboard objectives remove {self.sb_general}
scoreboard objectives remove {self.sb_sys}
data remove storage {self.storage} ret_val
data remove storage {self.storage} call
data remove storage {self.storage} version
data remove storage {self.storage} frame
data remove storage {self.storage} stack
data remove storage {self.storage} cond_stack
data remove storage {self.storage} loop_stack
data remove storage {self.storage} register
data remove storage {self.storage} cache
data remove storage {self.storage} mem
data remove storage {self.storage} constants
"""
        , macro=False)
        MCF.rewind()

        if not self._final_export:
            self.exportComponents()
        console.summarize()

    def initializeHelper(self, target: Callable) -> None:
        self._init_helper.append(target)

    def useConfig(self, cfg_map: ConfigMap) -> None:
        console.info('Using configuration:', cfg_map)
        # config query
        self._namespace = cfg_map.get("namespace", self._namespace)
        self._mcf_version = cfg_map.get("version", self._mcf_version)
        self._dist = cfg_map.get("dist", self._dist)
        self._prefix = cfg_map.get("prefix", self._prefix)
        self.do_gc = cfg_map.get("gc", self.do_gc)
        self._component_reg.clear()
        self._final_export = False
        self._tidied_up = False
        self._io_redirect = None
        self._context.clear()
        self._context_stack.clear()
        self._context_type = ['norm']
        self._last_ctx_type = 'norm'

        # name defines
        self.sb_general = f"emcf_{self._namespace}"
        self.sb_sys = f"emcf_{self._namespace}_sys"
        self.storage = f"{self._namespace}:emcf"

        # database
        self.database = MCFDataBase(self._mcf_version)

        # make file structure
        path_build = f"{self._dist}/{self._namespace}/function/emcf"
        self.wk_root = f"{self._dist}/{self._namespace}/function"
        self.database._mcf_path = os.path.join(self._dist, self._namespace)
        os.makedirs(path_build, exist_ok=True)
        files, _ = getMultiPaths(self.wk_root)
        for file in files:
            os.remove(file)

        # file io
        self._io_ptr = f"{self.wk_root}/main.mcfunction"

        # component initialize entrance
        self._cp_init_path, init_sig = self.makeFunction()

        with open(self._io_ptr, 'a', encoding='utf-8') as file:
            file.write(f"# {self._prefix} \n")
            file.write(
f"""scoreboard objectives add {self.sb_general} dummy
scoreboard objectives add {self.sb_sys} dummy
data modify storage {self.storage} version set value "{EMCF}"
data modify storage {self.storage} call set value """ + r"{}" + f"""
data modify storage {self.storage} frame set value """ + r"{}" + f"""
data modify storage {self.storage} stack set value []
data modify storage {self.storage} ret_val set value ""
data modify storage {self.storage} cond_stack set value []
data modify storage {self.storage} loop_stack set value []
data modify storage {self.storage} register set value ""
data modify storage {self.storage} cache set value """ + r"{}" + f"""
data modify storage {self.storage} mem set value """ + r"{}" + f"""
data modify storage {self.storage} constants set value """ + r"{}" + f"""
scoreboard players set {MCF.GENERAL} {self.sb_sys} 0
scoreboard players set {MCF.CALC_CONST} {self.sb_sys} 0
scoreboard players set {MCF.COND_LAST} {self.sb_sys} 0
scoreboard players set {MCF.TERMINATE} {self.sb_sys} 0
scoreboard players set {MCF.BUFFER1} {self.sb_sys} 0
scoreboard players set {MCF.BUFFER2} {self.sb_sys} 0
scoreboard players set {MCF.BUFFER3} {self.sb_sys} 0
scoreboard players set {MCF.BUFFER4} {self.sb_sys} 0
scoreboard players set {MCF.BUFFER5} {self.sb_sys} 0
scoreboard players set {MCF.BUFFER6} {self.sb_sys} 0
scoreboard players set {MCF.LOOP_EXIT} {self.sb_sys} 0
scoreboard players set {MCF.LOOP_CONT} {self.sb_sys} 0
function {init_sig}
"""
            )
        self._io_history.append(f"{self.wk_root}/main.mcfunction")
        console.info("Compiling functions...")
        # call functions in init helpers
        for call in self._init_helper: call(self)
        # fill up mc functions paths
        for func_meta in self._func_queue:
            func_meta._entry_path, func_meta._entry_sig = MCF.makeFunction()
            func_meta._body_path, func_meta._body_sig = MCF.makeFunction()
            func_meta._export_func.__mcfsignature__ = func_meta._entry_sig

    def getFID(self) -> str:
        return self._fool_id_generator.get()

    def makeFunction(self, name: str | None = None) -> tuple[str, str]:
        if name is None:
            name = self._fool_id_generator.get()
            path = f"{self.wk_root}/emcf/{name}.mcfunction"
            sig = f"{self._namespace}:emcf/{name}"
        else:
            path = f"{self.wk_root}/{name}.mcfunction"
            sig = f"{self._namespace}:{name}"
        return path, sig

    def useComponent(self, cp_id: str, macros: dict[str, str]) -> None:
        if not self.database.pushComponent(cp_id, macros):
            console.error(
                MCFComponentError(
                    f"Can not find component '{cp_id}'."
                )
            )

    def builtinSign(self, func_id: str) -> str:
        check = self._component_reg.get(func_id, None)
        if check is not None: return check
        if not self.database.validateSign(func_id):
            console.error(
                MCFComponentError(
                    f"Can not find component function '{func_id}', " + 
                    "maybe it's not exported or does not exist."
                )
            )
        signature = f"{self._namespace}:emcf/{self._fool_id_generator.get()}"
        self._component_reg[func_id] = signature
        return signature

    def _merge_signatures(self, target: dict[str, list[str]]) -> None:
        for cp_id in target.keys():
            # append fool id signatures & sign
            here = self._component_reg.get(cp_id, None)
            if here is not None:
                fid = here[here.rfind('/') + 1:]
                target[cp_id].append(f"{self.wk_root}/emcf/{fid}.mcfunction")
                target[cp_id].append(here)
            else:
                new_path, fid = self.makeFunction()
                target[cp_id].append(new_path)
                target[cp_id].append(fid)

    def exportComponents(self) -> None:
        self._final_export = True
        console.info("Exporting used components...")
        self.database.writeComponents(
            self._merge_signatures,
            self._cp_init_path
        )

    def write(self, command_lines: str, macro: bool) -> None:
        """向当前函数文件内写入命令"""
        prefix = '$' if macro else ''
        if self._io_redirect is not None:
            self._io_redirect.write(prefix + command_lines)
        else:
            with open(self._io_ptr, 'a', encoding='utf-8') as file:
                file.write(prefix + command_lines)

    def forward(self, path: str) -> None:
        self._io_history.append(path)
        self._io_ptr = path

    def rewind(self) -> None:
        if len(self._io_history) <= 1: return
        self._io_history.pop()
        self._io_ptr = self._io_history[-1]

    def redirect(self, dist: Any | None) -> None:
        self._io_redirect = dist

    def addContext(self, variable: Any) -> None:
        shadow = variable.duplicate(None, True)
        shadow._mcf_id = variable._mcf_id
        shadow._gc_sign = 'shadow'
        self._context[shadow._mcf_id] = shadow

    def removeContext(self, variable: Any) -> None:
        self._context.pop(variable._mcf_id)

MCF = MCFCore()
