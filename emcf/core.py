
from .database import *
from ._utils import getMultiPaths
from typing import TypeAlias, Any, Literal, TextIO, Callable, Protocol
import os, random

EMCF = "a0.1.0"

ConfigMap: TypeAlias = dict[Literal[
    "namespace", "version", "dist", "prefix", "gc"
], Any]

class MCFWriter(Protocol):
    def __call__(self, io: TextIO, *args: Any): ...

MCFVersion: TypeAlias = Literal[1204, 1211]

class FoolID:
    _present: list[int]
    _chars: list[str]
    def __init__(self):
        self._present = []
        self._chars = []

        self._present = [0]
        for i in range(ord('a'), ord('z')):
            self._chars.append(chr(i))
        random.shuffle(self._chars)
    
    def get(self) -> str:
        fid = ''.join([self._chars[idx] for idx in self._present])
        last = len(self._present)
        self._present[last - 1] += 1
        for i in range(last - 1, -1, -1):
            if self._present[i] >= len(self._chars):
                if i == 0:
                    self._present[i] = 0
                    self._present.insert(0, 0)
                    break
                else:
                    self._present[i] = 0
                    self._present[i - 1] += 1
        return fid

class MCFunction:
    _namespace: str
    _mcf_version: MCFVersion
    _dist: str
    wk_root: str

    _operation_stack: list
    _fool_id_generator: FoolID
    _prefix: str
    _io_ptr: str
    _io_history: list[str]
    _component_reg: dict[str, str]
    _context: list
    _context_stack: list[list]

    sb_general: str
    sb_sys: str
    storage: str
    database: MCFDataBase
    do_gc: bool
    stop_gc: bool

    GENERAL = "reg1"
    CALC_CONST = "reg2"
    COND_LAST = "reg3"
    TERMINATE = "reg4"

    def __init__(self):
        self._operation_stack = []
        self._mcf_version = 1204
        self._dist = ".\\build"
        self.wk_root = ".\\build\\default\\functions"
        self._namespace = "default"
        self._prefix = """--- Generated by EMCF ---"""
        self._fool_id_generator = FoolID()
        self._io_history = []
        self._io_ptr = None
        self._component_reg = dict()
        self._context = []
        self._context_stack = []
        self.do_gc = True
        self.stop_gc = False

    def useConfig(self, cfg_map: ConfigMap) -> None:
        # config query
        self._namespace = cfg_map.get("namespace", self._namespace)
        self._mcf_version = cfg_map.get("version", self._mcf_version)
        self._dist = cfg_map.get("dist", self._dist)
        self._prefix = cfg_map.get("prefix", self._prefix)
        self.do_gc = cfg_map.get("gc", self.do_gc)
        self._component_reg.clear()
        self._context.clear()
        self._context_stack.clear()

        # name defines
        self.sb_general = f"emcf_{self._namespace}"
        self.sb_sys = f"emcf_{self._namespace}_sys"
        self.storage = f"{self._namespace}:emcf"

        # database
        self.database = MCFDataBase(self._mcf_version)

        # make file structure
        path_build = f"{self._dist}\\{self._namespace}\\functions\\emcf"
        self.wk_root = f"{self._dist}\\{self._namespace}\\functions"
        os.makedirs(path_build, exist_ok=True)
        files, _ = getMultiPaths(self.wk_root)
        for file in files:
            os.remove(file)

        # file io
        self._io_ptr = f"{self.wk_root}\\main.mcfunction"

        with open(self._io_ptr, 'a', encoding='utf-8') as file:
            file.write(f"# {self._prefix} \n")
            file.write(
f"""scoreboard objectives add {self.sb_general} dummy
scoreboard objectives add {self.sb_sys} dummy
data modify storage {self.storage} version set value "{EMCF}"
data modify storage {self.storage} call set value """ + r"{}" + f"""
data modify storage {self.storage} frame set value """ + r"{}" + f"""
data modify storage {self.storage} stack set value []
data modify storage {self.storage} ret_val set value ""
data modify storage {self.storage} cond_stack set value []
data modify storage {self.storage} register set value ""
scoreboard players set {MCF.GENERAL} {self.sb_sys} 0
scoreboard players set {MCF.CALC_CONST} {self.sb_sys} 0
scoreboard players set {MCF.COND_LAST} {self.sb_sys} 0
scoreboard players set {MCF.TERMINATE} {self.sb_sys} 0
"""
            )
        self._io_history.append(f"{self.wk_root}\\main.mcfunction")

    def getFID(self) -> str:
        return self._fool_id_generator.get()

    def makeFunction(self, name: str | None = None) -> tuple[str, str]:
        if name is None:
            name = self._fool_id_generator.get()
            path = f"{self.wk_root}\\emcf\\{name}.mcfunction"
            sig = f"{self._namespace}:emcf/{name}"
        else:
            path = f"{self.wk_root}\\{name}.mcfunction"
            sig = f"{self._namespace}:{name}"
        return path, sig

    def exportComponent(self, cp_id: str) -> None:
        cps = self.database.loadComponent(cp_id)
        for cp in cps:
            path, key = cp
            w_path, sig = self.makeFunction()
            with open(path, 'r', encoding='utf-8') as rd:
                content = rd.read()
            with open(w_path, 'w', encoding='utf-8') as wt :
                wt.write(content)
            self._component_reg[key] = sig

    def builtinSign(self, func_id: str) -> str:
        return self._component_reg.get(func_id)

    def write(self, _writer: MCFWriter, *args: Any) -> None:
        with open(self._io_ptr, 'a') as file:
            _writer(file, *args)

    def forward(self, path: str) -> None:
        self._io_history.append(path)
        self._io_ptr = path

    def rewind(self) -> None:
        if len(self._io_history) <= 1: return
        self._io_history.pop()
        self._io_ptr = self._io_history[-1]

MCF = MCFunction()
